やつたこと
    進捗
        学会発表のスクリプトを書いた．
    精進
        ABC 184 F: 半分全列挙のザ・典型問題で，言ふことなし．
        CODE FESTIVAL 2016 qual C C: T_{i-1} < T_i なら h_i = T_i と確定し， T_{i-1} == T_i なら h_i <= T_i である． A からも同様の条件が得られる．
        ABC 271 E:
            dp[k][i] = 都市 1 から i までいくつかの道を使って移動する経路であって，通る道の番号を通った順に並べた列は (E_1, ..., E_k) の部分列である経路のうち，長さの合計の最小値 としたいが，これは大きすぎる．
            しかし k を反復する際に，更新されるのは道 E_k の終端だけであることに着目すると，インラインの動的計画法が使へる．
            このコンテストには出てるので解説は見たことあった．
                当時は全く理解できなかったので，成長．
        ABC 98 D: 2 数 x, y について， x&y == 0 であることと x+y == x^y であることは同値である．これを用いてしゃくとり法をする．
    AtCoder Beginner Contest 279
        難しすぎません？ A ~ E まで解けた．難しすぎて青パフォ出た．
        D: 何故か相加相乗平均しか思ひつかなかった． E を解いてから戻ってきたら隣接項の符号を確認すればいいことにすぐ気づき AC．
        E: B_{A_k} と B_{A_k+1} の値を入れ替へることを単に操作 k と呼ぶことに する． 二次元配列 dp[M][N] を以下で定める．
            各 dp[k][j] は 1 以上 M 以下の整数からなる集合の部分集合である．
            dp[0][1] = {1, ..., M}， dp[0][i] = {} (i = 2, ..., N)．
            dp[k][i] は以下で遷移する．
                dp[k][A_k+1] = dp[k-1][A_k] \ {k}
                dp[k][A_k] = dp[k-1][A_k+1] \ {k}
                もし dp[k-1][A_k] に k が含まれるなら， dp[k][A_k] に k を追加する．
                もし dp[k-1][A_k+1] に k が含まれるなら， dp[k][A_k+1] に k を追加する．
                それ以外の dp[k][*] については， dp[k-1][*]．
            これはまさに今日精進したインラインの動的計画法でできる．
        F: 素集合データ構造を使ってなんとかするところまでは想像できたが，実装が間に合はず．

けふの酒
    アサヒスーパドライ
